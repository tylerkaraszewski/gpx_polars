<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>GPX to Polars</title>
<script type="text/javascript">
    var gpx;

    // This is all of the speeds we have for any given angle, where the angles are in 3 degree buckets (so there are
    // 120 of them).
    var buckets = [];
    for (var i = 0; i < 120; i++) {
        buckets.push([]);
    }

    // This is the best speeds for each bucket, which is the average of the top three in each bucket.
    var bestSpeeds = [];

    window.onload = function() {
        // Set up the slider.
        var angleSlider = document.getElementById("angle");
        document.getElementById("current_angle").innerHTML = "Current Angle: " + angleSlider.value;
        angleSlider.addEventListener("change", function(){
            document.getElementById("current_angle").innerHTML = "Current Angle: " + angleSlider.value;
            draw();
        }, false);

        // Set up the file loader.
        var jsonFileInput = document.getElementById("gpx");
        jsonFileInput.addEventListener("input", handleFiles, false);
        function handleFiles() {
            var reader = new FileReader();
            reader.onload = function(evt) {
                try {
                    var parser = new DOMParser();
                    gpx = parser.parseFromString(reader.result, "application/xml");
                    document.getElementById("loadingScreen").className = "hidden";
                    loadComplete();
                } catch (e) {
                    console.warn(e);
                }
            };
            reader.readAsText(jsonFileInput.files[0]);
        }
    }

    function loadComplete() {
        var trks = gpx.getElementsByTagName("trk");
        if (trks.length != 1) {
            console.warn("Unexpected number of tracks");
            return;
        }
        var trksegs = trks[0].getElementsByTagName("trkseg");
        if (trks.length > 1) {
            console.warn("Unexpected number of track segments, only using the first one.");
        }
        if (trks.length == 0) {
            console.warn("No track segments.");
            return;
        }

        // Ok, this is hopefully usable.
        var trkseg = trksegs[0];

        // Now we'll start iterating all of our points.
        var current = trkseg.firstElementChild;
        var previous = null;
        while (current) {
            // Make sure this looks correct.
            if (current.nodeName !== "trkpt") {
                console.warn("Invalid node, skipping.", current);
                continue;
            }

            // Parse the useful information out of our point.
            var parsed = {};
            var lat = parseFloat(current.getAttribute("lat"));
            var lon = parseFloat(current.getAttribute("lon"));
            var time;
            try {
                // TODO: This is apparently frowned upon, but it's working with Garmin's date stamps and my Firefox.
                time = Date.parse(current.getElementsByTagName("time")[0].innerHTML);
            } catch (e) {
                console.warn("Couldn't parse time for element, skipping.", current);
                continue;
            }
            parsed.lat = lat;
            parsed.lon = lon;
            parsed.time = time;

            // If we haven't set the previous node yet, we can't go on to the next without doing anything else.
            if (previous) {

                // Now we have a parsed object, and a previous parsed object, we need to find:
                // 1. Distance.
                // 2. Speed.
                // 3. Bearing.
                // 4. Time elapsed.

                var elapsedTime = parsed.time - previous.time;
                var distanceMeters = getDistanceInMeters(previous.lat, previous.lon, parsed.lat, parsed.lon);
                var distanceNM = distanceMeters / 1852;
                var speedKnots = (distanceMeters / 1852) / ((elapsedTime / 1000) / (60 * 60));
                var bearing = getBearingInDegrees(previous.lat, previous.lon, parsed.lat, parsed.lon);

                // Now save this data.
                var index = (Math.floor(Math.floor(bearing + 0.5) / 3)) % buckets.length;
                buckets[index].push(speedKnots);
            }
            // And move on to the next one.
            previous = parsed;
            current = current.nextElementSibling;
        }

        postProcess();
    }

    function postProcess() {
        for (var i = 0; i < buckets.length; i++) {
            var array = buckets[i];
            array.sort(function(a, b){return b - a});
            var top3 = array.slice(0, 3);
            if (top3.length == 0) {
                top3.push(0);
            }
            var sum = 0;
            for (var j = 0; j < top3.length; j++) {
                sum += top3[j];
            }
            sum /= top3.length;
            bestSpeeds.push(sum);
        }

        draw();
    }

    // https://stackoverflow.com/questions/7570808/how-do-i-calculate-the-difference-of-two-angle-measures/30887154
    function angleFromWind(heading, wind) {
        var phi = Math.abs(heading - wind) % 360;
        var angleOffTheWind = phi > 180 ? 360 - phi : phi;
        if (angleOffTheWind > 90) {
            angleOffTheWind = 180 - angleOffTheWind;
        }
        return angleOffTheWind;
    }

    function draw() {
        // If there's no speed data (because someone dragged the slider before loading a file), there's nothing to
        if (!bestSpeeds.length) {
            return;
        }

        // Get the angle the slider is set to.
        var angle = parseFloat(document.getElementById("angle").value);
        var count = bestSpeeds.length;

        var max = 0;
        for (var i = 0; i < count; i++) {
            if (bestSpeeds[i] > max) {
                max = bestSpeeds[i];
            }
        }
        max = Math.ceil(max) + 2;

        var canvas = document.getElementById('canvas');
        if (!canvas) {
            canvas = document.createElement('canvas');
            canvas.width = 600 * window.devicePixelRatio;
            canvas.height = 600 * window.devicePixelRatio;
            canvas.id = 'canvas';
            document.getElementById('canvas_container').appendChild(canvas);
        }
        var ctx = canvas.getContext('2d');

        // Save in the default, just created stated.
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Scale the canvas to fit a unit circle. 1200 is the magic number specified in the size/width of the element.
        ctx.scale(1200 / 2, 1200 / 2);
        ctx.lineWidth = 2 / 1200;

        // Translate it so that the origin is in the middle.
        ctx.translate(1, 1);

        // Flip the Y-axis.
        ctx.scale(1, -1);

        // Actually draw the main polar shape. We do this first so the labels go over it.
        ctx.save()
        ctx.rotate((Math.PI / 180) * (-1.5 + angle));
        ctx.beginPath();
        ctx.moveTo(0, bestSpeeds[0] / max);
        for (var i = 1; i < count; i++) {
            ctx.rotate((Math.PI / 180) * -3);
            ctx.lineTo(0, bestSpeeds[i] / max);
        }
        ctx.closePath();
        ctx.fillStyle = 'rgba(128, 148, 224, 1)';
        ctx.fill();
        ctx.rotate((Math.PI / 180) * -1.5);
        ctx.restore();

        // Same thing again, but for VMG.
        ctx.save()
        ctx.rotate((Math.PI / 180) * (-1.5 + angle));
        ctx.beginPath();
        var compassAngle = 1.5;
        ctx.moveTo(0, (bestSpeeds[i] / max) * Math.cos((Math.PI / 180) * angleFromWind(compassAngle, angle)));
        for (var i = 1; i < count; i++) {
            ctx.rotate((Math.PI / 180) * -3);
            compassAngle += 3;
            ctx.lineTo(0, (bestSpeeds[i] / max) * Math.cos((Math.PI / 180) * angleFromWind(compassAngle, angle)));
        }
        ctx.closePath();
        ctx.fillStyle = 'rgba(224, 148, 128, 1)';
        ctx.fill();
        ctx.rotate((Math.PI / 180) * -1.5);
        ctx.restore();

        // Draw some angle lines.
        ctx.save();
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
        ctx.beginPath();
        for (var i = 0; i < 6; i++) {
            ctx.moveTo(-1, 0);
            ctx.lineTo(1, 0);
            ctx.stroke();
            ctx.rotate((Math.PI / 180) * (30));
        }
        ctx.restore();

        // Draw some circles with labels.
        // NOTE: We scale everything by 1/100th for this, because the fonts won't draw correctly in tiny fractional
        // sizes.
        ctx.save();
        ctx.scale(1, -1);
        ctx.scale(1/1000, 1/1000);
        ctx.lineWidth = ctx.lineWidth * 1000;
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.25)';
        ctx.textBaseline = 'bottom';
        ctx.font = '36px sans-serif';
        for (var i = 2; i < max; i += 2) {
            ctx.beginPath();
            ctx.arc(0, 0, (i / max) * 1000, 0, Math.PI * 2);
            ctx.stroke();

            var label = '' + i;// + 'kts';
            var textWidth = ctx.measureText(label).width;
            ctx.fillText(label, ((i / max) * 1000) - textWidth - 10, 0);
        }
        ctx.restore();

        // Put it back to the original.
        ctx.restore();
    }

    // Copied from: https://www.movable-type.co.uk/scripts/latlong.html
    function getDistanceInMeters(lat1, lon1, lat2, lon2) {
        var R = 6371e3; // metres
        var φ1 = lat1 * (Math.PI / 180);
        var φ2 = lat2 * (Math.PI / 180);
        var Δφ = (lat2-lat1) * (Math.PI / 180);
        var Δλ = (lon2-lon1) * (Math.PI / 180);

        var a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
            Math.cos(φ1) * Math.cos(φ2) *
            Math.sin(Δλ/2) * Math.sin(Δλ/2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        var d = R * c;

        return d;
    }
    function getBearingInDegrees(lat1, lon1, lat2, lon2) {
        var φ1 = lat1 * (Math.PI / 180);
        var λ1 = lon1 * (Math.PI / 180);
        var φ2 = lat2 * (Math.PI / 180);
        var λ2 = lon2 * (Math.PI / 180);
        var y = Math.sin(λ2-λ1) * Math.cos(φ2);
        var x = Math.cos(φ1)*Math.sin(φ2) -
                Math.sin(φ1)*Math.cos(φ2)*Math.cos(λ2-λ1);
        var brng = Math.atan2(y, x) * (180 / Math.PI);

        return (brng + 360) % 360;
    }

</script>
<style type="text/css">
html {
    font-family: sans-serif;
}
.hidden {
    display: none;
}
#canvas {
    width: 600px;
    height: 600px;
}
#wind_angle h1 {
    font-weight: bold;
    font-size: 16px;
    margin: 0;
    margin-top: 10px;
    padding: 0;
}
#wind_angle > span {
    font-size: 16px;
    display: inline-box;
    position: relative;
    bottom: 11px;
}
/*
All this shit taken from:
https://www.cssportal.com/style-input-range/
*/
input[type=range] {
  height: 34px;
  -webkit-appearance: none;
  margin: 0;
  width: 600px;
}
input[type=range]:focus {
  outline: none;
}
input[type=range]::-webkit-slider-runnable-track {
  width: 100%;
  height: 11px;
  cursor: pointer;
  animate: 0.2s;
  box-shadow: 1px 1px 1px #000000;
  background: #74A9D8;
  border-radius: 1px;
  border: 0px solid #010101;
}
input[type=range]::-webkit-slider-thumb {
  box-shadow: 1px 1px 1px #000031;
  border: 1px solid #00001E;
  height: 26px;
  width: 26px;
  border-radius: 15px;
  background: #FFFFFF;
  cursor: pointer;
  -webkit-appearance: none;
  margin-top: -8px;
}
input[type=range]:focus::-webkit-slider-runnable-track {
  background: #74A9D8;
}
input[type=range]::-moz-range-track {
  width: 100%;
  height: 11px;
  cursor: pointer;
  animate: 0.2s;
  box-shadow: 1px 1px 1px #000000;
  background: #74A9D8;
  border-radius: 1px;
  border: 0px solid #010101;
}
input[type=range]::-moz-range-thumb {
  box-shadow: 1px 1px 1px #000031;
  border: 1px solid #00001E;
  height: 26px;
  width: 26px;
  border-radius: 15px;
  background: #FFFFFF;
  cursor: pointer;
}
input[type=range]::-ms-track {
  width: 100%;
  height: 11px;
  cursor: pointer;
  animate: 0.2s;
  background: transparent;
  border-color: transparent;
  color: transparent;
}
input[type=range]::-ms-fill-lower {
  background: #74A9D8;
  border: 0px solid #010101;
  border-radius: 2px;
  box-shadow: 1px 1px 1px #000000;
}
input[type=range]::-ms-fill-upper {
  background: #74A9D8;
  border: 0px solid #010101;
  border-radius: 2px;
  box-shadow: 1px 1px 1px #000000;
}
input[type=range]::-ms-thumb {
  margin-top: 1px;
  box-shadow: 1px 1px 1px #000031;
  border: 1px solid #00001E;
  height: 26px;
  width: 26px;
  border-radius: 15px;
  background: #FFFFFF;
  cursor: pointer;
}
input[type=range]:focus::-ms-fill-lower {
  background: #74A9D8;
}
input[type=range]:focus::-ms-fill-upper {
  background: #74A9D8;
}
</style>
</head>
<body>
    <div id="loadingScreen">
        <h1>Load a GPX File</h1>
        <input type="file" id="gpx">
    </div>
    <div id="wind_angle">
        <h1>Wind Angle (in degrees, default is south)</h1>
        <span>0</span> <input id="angle" type="range" min="0" max="360" step="0.5"></input> <span>360</span>
        <div id="current_angle"></div>
    </div>
    <div id="canvas_container"><canvas id="canvas" width="1200" height="1200"></canvas></div>
</body>
</html>
