<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>GPX to Polars</title>
<script type="text/javascript">
    var gpx1, gpx2;

    // Use integers between 1 and 6, inclusive.
    var bucketDegreeIncrement = 3;
    var buckets1;
    var buckets2;
    var bestSpeeds1 = [];
    var bestSpeeds2 = [];

    function initBucketsAndSpeeds(which) {
        if (which == 1) {
            buckets1 = [];
            bestSpeeds1 = [];
            for (var i = 0; i < (360 / bucketDegreeIncrement); i++) {
                buckets1.push([]);
            }
        } else {
            buckets2 = [];
            bestSpeeds2 = [];
            for (var i = 0; i < (360 / bucketDegreeIncrement); i++) {
                buckets2.push([]);
            }
        }
    }

    // This is the best speeds for each bucket, which is the average of the top three in each bucket.

    window.onload = function() {
        // Set up the slider.
        var angleSlider = document.getElementById("angle");
        document.getElementById("current_angle").innerHTML = "Current Angle: " + angleSlider.value;
        angleSlider.addEventListener("change", function(){
            document.getElementById("current_angle").innerHTML = "Current Angle: " + angleSlider.value;
            draw();
        }, false);

        // Set up the file loaders.
        var jsonFileInput1 = document.getElementById("gpx1");
        var jsonFileInput2 = document.getElementById("gpx2");
        jsonFileInput1.addEventListener("change", handleFiles, false);
        jsonFileInput2.addEventListener("change", handleFiles, false);
        function handleFiles(e) {
            var reader = new FileReader();
            reader.onload = function() {
                try {
                    var parser = new DOMParser();
                    if (e.target.id == "gpx1") {
                        gpx1 = parser.parseFromString(reader.result, "application/xml");
                    } else {
                        gpx2 = parser.parseFromString(reader.result, "application/xml");
                    }
                    loadComplete(e.target.id);
                } catch (e) {
                    console.warn(e);
                }
            };
            reader.readAsText(e.target.files[0]);
        }

        document.getElementById("advanced_settings_toggle").addEventListener("click", function() {
            if (document.getElementById("advanced_settings").style.display == "") {
                document.getElementById("advanced_settings").style.display = "none";
                document.getElementById("advanced_settings_toggle").innerHTML =
                document.getElementById("advanced_settings_toggle").innerHTML.replace(/\-/, "+");
            } else {
                document.getElementById("advanced_settings").style.display = "";
                document.getElementById("advanced_settings_toggle").innerHTML =
                document.getElementById("advanced_settings_toggle").innerHTML.replace(/\+/, "-");
            }
        }, false);

        document.getElementById("bucket_size").addEventListener("change", function() {
            bucketDegreeIncrement = Math.floor(document.getElementById("bucket_size").value);
            loadComplete("gpx1");
            loadComplete("gpx2");
        }, false);
    }

    function loadComplete(targetName) {
        var trks;
        if (targetName == "gpx1") {
            trks = gpx1.getElementsByTagName("trk");
            initBucketsAndSpeeds(1);
        } else {
            trks = gpx2.getElementsByTagName("trk");
            initBucketsAndSpeeds(2);
        }
        if (trks.length !== 0 && trks.length !== 1) {
            console.warn("Unexpected number of tracks");
            return;
        }
        if (trks.length === 0) {
            return;
        }
        var trksegs = trks[0].getElementsByTagName("trkseg");
        if (trks.length > 1) {
            console.warn("Unexpected number of track segments, only using the first one.");
        }
        if (trks.length == 0) {
            console.warn("No track segments.");
            return;
        }

        // Ok, this is hopefully usable.
        var trkseg = trksegs[0];

        // Now we'll start iterating all of our points.
        var current = trkseg.firstElementChild;
        var previous = null;
        while (current) {
            // Make sure this looks correct.
            if (current.nodeName !== "trkpt") {
                console.warn("Invalid node, skipping.", current);
                current = current.nextElementSibling;
                continue;
            }

            // Parse the useful information out of our point.
            var parsed = {};
            var lat = parseFloat(current.getAttribute("lat"));
            var lon = parseFloat(current.getAttribute("lon"));
            var time;
            try {
                // TODO: This is apparently frowned upon, but it's working with Garmin's date stamps and my Firefox.
                time = Date.parse(current.getElementsByTagName("time")[0].innerHTML);
            } catch (e) {
                console.warn("Couldn't parse time for element, skipping.", current);
                current = current.nextElementSibling;
                continue;
            }
            parsed.lat = lat;
            parsed.lon = lon;
            parsed.time = time;

            // If we haven't set the previous node yet, we can't go on to the next without doing anything else.
            if (previous) {

                // Now we have a parsed object, and a previous parsed object, we need to find:
                // 1. Distance.
                // 2. Speed.
                // 3. Bearing.
                // 4. Time elapsed.

                var elapsedTime = parsed.time - previous.time;
                var distanceMeters = getDistanceInMeters(previous.lat, previous.lon, parsed.lat, parsed.lon);
                var distanceNM = distanceMeters / 1852;
                var speedKnots = (distanceMeters / 1852) / ((elapsedTime / 1000) / (60 * 60));
                var bearing = getBearingInDegrees(previous.lat, previous.lon, parsed.lat, parsed.lon);

                // Now save this data.
                var index = (Math.floor(Math.floor(bearing + 0.5) / bucketDegreeIncrement)) % buckets1.length;
                if (targetName == "gpx1") {
                    buckets1[index].push(speedKnots);
                } else {
                    buckets2[index].push(speedKnots);
                }
            }
            // And move on to the next one.
            previous = parsed;
            current = current.nextElementSibling;
        }

        postProcess(targetName);
    }

    function postProcess(targetName) {
        for (var i = 0; i < buckets1.length; i++) {
            var array;
            if (targetName == "gpx1") {
                array = buckets1[i];
            } else {
                array = buckets2[i];
            }
            array.sort(function(a, b){return b - a});
            var top3 = array.slice(0, 3);
            if (top3.length == 0) {
                top3.push(0);
            }
            var sum = 0;
            for (var j = 0; j < top3.length; j++) {
                sum += top3[j];
            }
            sum /= top3.length;
            if (targetName == "gpx1") {
                bestSpeeds1.push(sum);
            } else {
                bestSpeeds2.push(sum);
            }
        }

        draw();
    }

    // https://stackoverflow.com/questions/7570808/how-do-i-calculate-the-difference-of-two-angle-measures/30887154
    function angleFromWind(heading, wind) {
        var phi = Math.abs(heading - wind) % 360;
        var angleOffTheWind = phi > 180 ? 360 - phi : phi;
        if (angleOffTheWind > 90) {
            angleOffTheWind = 180 - angleOffTheWind;
        }
        return angleOffTheWind;
    }

    function draw() {
        // If there's no speed data (because someone dragged the slider before loading a file), there's nothing to
        if (!bestSpeeds1.length && !bestSpeeds2.length) {
            return;
        }

        // Get the angle the slider is set to.
        var angle = parseFloat(document.getElementById("angle").value);

        // Find the highest speed.
        var count = Math.max(bestSpeeds1.length, bestSpeeds2.length);
        var max = 0;
        for (var i = 0; i < count; i++) {
            if (bestSpeeds1.length && bestSpeeds1[i] > max) {
                max = bestSpeeds1[i];
            }
            if (bestSpeeds2.length && bestSpeeds2[i] > max) {
                max = bestSpeeds2[i];
            }
        }
        max = Math.ceil(max) + 2;

        var canvas = document.getElementById('canvas');
        if (!canvas) {
            canvas = document.createElement('canvas');
            canvas.width = 600 * window.devicePixelRatio;
            canvas.height = 600 * window.devicePixelRatio;
            canvas.id = 'canvas';
            document.getElementById('canvas_container').appendChild(canvas);
        }
        var ctx = canvas.getContext('2d');

        // Save in the default, just created stated.
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Scale the canvas to fit a unit circle. 1200 is the magic number specified in the size/width of the element.
        ctx.scale(1200 / 2, 1200 / 2);
        ctx.lineWidth = 2 / 1200;

        // Translate it so that the origin is in the middle.
        ctx.translate(1, 1);

        // Flip the Y-axis.
        ctx.scale(1, -1);

        // Actually draw the main polar shape. We do this first so the labels go over it.
        for (var outline = 0; outline < 2; outline++) {
            var bestSpeeds;
            if (outline == 0) {
                bestSpeeds = bestSpeeds1;
            } else {
                bestSpeeds = bestSpeeds2;
            }
            if (bestSpeeds.length === 0) {
                // Skip any undefined sections.
                continue;
            }
            ctx.save()
            ctx.rotate((Math.PI / 180) * (-0.5 * bucketDegreeIncrement + angle));
            ctx.beginPath();
            ctx.moveTo(0, bestSpeeds[0] / max);
            for (var i = 1; i < count; i++) {
                ctx.rotate((Math.PI / 180) * -1 * bucketDegreeIncrement);
                ctx.lineTo(0, bestSpeeds[i] / max);
            }
            ctx.closePath();
            if (outline == 0) {
                ctx.fillStyle = 'rgba(128, 148, 224, 1)';
                ctx.fill();
            } else {
                ctx.setLineDash([0.01, 0.01]);
                ctx.lineWidth = ctx.lineWidth * 1.5;//2 / 1200;
                ctx.strokeStyle = 'rgba(30, 30, 255, 1)';
                ctx.stroke();
            }
            ctx.rotate((Math.PI / 180) * -0.5 * bucketDegreeIncrement);
            ctx.restore();

            // Same thing again, but for VMG.
            ctx.save()
            ctx.rotate((Math.PI / 180) * (-0.5 * bucketDegreeIncrement + angle));
            ctx.beginPath();
            var compassAngle = 0.5 * bucketDegreeIncrement;
            ctx.moveTo(0, (bestSpeeds[i] / max) * Math.cos((Math.PI / 180) * angleFromWind(compassAngle, angle)));
            for (var i = 1; i < count; i++) {
                ctx.rotate((Math.PI / 180) * -1 * bucketDegreeIncrement);
                compassAngle += bucketDegreeIncrement;
                ctx.lineTo(0, (bestSpeeds[i] / max) * Math.cos((Math.PI / 180) * angleFromWind(compassAngle, angle)));
            }
            ctx.closePath();
            if (outline == 0) {
                ctx.fillStyle = 'rgba(224, 148, 128, 1)';
                ctx.fill();
            } else {
                ctx.setLineDash([0.01, 0.01]);
                ctx.lineWidth = ctx.lineWidth * 1.5;//2 / 1200;
                ctx.strokeStyle = 'rgba(255, 30, 30, 1)';
                ctx.stroke();
            }
            ctx.rotate((Math.PI / 180) * -0.5 * bucketDegreeIncrement);
            ctx.restore();
        }

        // Draw some angle lines.
        ctx.save();
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
        ctx.beginPath();
        for (var i = 0; i < 6; i++) {
            ctx.moveTo(-1, 0);
            ctx.lineTo(1, 0);
            ctx.stroke();
            ctx.rotate((Math.PI / 180) * (30));
        }
        ctx.restore();

        // Draw some circles with labels.
        // NOTE: We scale everything by 1/100th for this, because the fonts won't draw correctly in tiny fractional
        // sizes.
        ctx.save();
        ctx.scale(1, -1);
        ctx.scale(1/1000, 1/1000);
        ctx.lineWidth = ctx.lineWidth * 1000;
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.25)';
        ctx.textBaseline = 'bottom';
        ctx.font = '36px sans-serif';
        for (var i = 2; i < max; i += 2) {
            ctx.beginPath();
            ctx.arc(0, 0, (i / max) * 1000, 0, Math.PI * 2);
            ctx.stroke();

            var label = '' + i;// + 'kts';
            var textWidth = ctx.measureText(label).width;
            ctx.fillText(label, ((i / max) * 1000) - textWidth - 10, 0);
        }
        ctx.restore();

        // Put it back to the original.
        ctx.restore();
    }

    // Copied from: https://www.movable-type.co.uk/scripts/latlong.html
    function getDistanceInMeters(lat1, lon1, lat2, lon2) {
        var R = 6371e3; // metres
        var φ1 = lat1 * (Math.PI / 180);
        var φ2 = lat2 * (Math.PI / 180);
        var Δφ = (lat2-lat1) * (Math.PI / 180);
        var Δλ = (lon2-lon1) * (Math.PI / 180);

        var a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
            Math.cos(φ1) * Math.cos(φ2) *
            Math.sin(Δλ/2) * Math.sin(Δλ/2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        var d = R * c;

        return d;
    }
    function getBearingInDegrees(lat1, lon1, lat2, lon2) {
        var φ1 = lat1 * (Math.PI / 180);
        var λ1 = lon1 * (Math.PI / 180);
        var φ2 = lat2 * (Math.PI / 180);
        var λ2 = lon2 * (Math.PI / 180);
        var y = Math.sin(λ2-λ1) * Math.cos(φ2);
        var x = Math.cos(φ1)*Math.sin(φ2) -
                Math.sin(φ1)*Math.cos(φ2)*Math.cos(λ2-λ1);
        var brng = Math.atan2(y, x) * (180 / Math.PI);

        return (brng + 360) % 360;
    }

</script>
<style type="text/css">
html {
    font-family: sans-serif;
}
.hidden {
    display: none;
}
#canvas {
    width: 600px;
    height: 600px;
}
#wind_angle h1 {
    font-weight: bold;
    font-size: 14px;
    margin: 0;
    margin-top: 16px;
    padding: 0;
}
#wind_angle > span {
    font-size: 16px;
    display: inline-box;
    position: relative;
    bottom: 11px;
}
.gpx_label {
    font-size: 14px;
    font-weight: bold;
    margin-bottom: 2px;
    margin-top: 16px;
}

#advanced_settings {
    padding: 6px;
    border: 1px solid black;
    background-color: #EEE;
    max-width: 600px;
}
#advanced_settings_toggle:hover {
    cursor: pointer;
}
/*
All this shit taken from:
https://www.cssportal.com/style-input-range/
*/
input[type=range] {
  height: 34px;
  -webkit-appearance: none;
  margin: 0;
  width: 600px;
}
input[type=range]:focus {
  outline: none;
}
input[type=range]::-webkit-slider-runnable-track {
  width: 100%;
  height: 11px;
  cursor: pointer;
  animate: 0.2s;
  box-shadow: 1px 1px 1px #000000;
  background: #74A9D8;
  border-radius: 1px;
  border: 0px solid #010101;
}
input[type=range]::-webkit-slider-thumb {
  box-shadow: 1px 1px 1px #000031;
  border: 1px solid #00001E;
  height: 26px;
  width: 26px;
  border-radius: 15px;
  background: #FFFFFF;
  cursor: pointer;
  -webkit-appearance: none;
  margin-top: -8px;
}
input[type=range]:focus::-webkit-slider-runnable-track {
  background: #74A9D8;
}
input[type=range]::-moz-range-track {
  width: 100%;
  height: 11px;
  cursor: pointer;
  animate: 0.2s;
  box-shadow: 1px 1px 1px #000000;
  background: #74A9D8;
  border-radius: 1px;
  border: 0px solid #010101;
}
input[type=range]::-moz-range-thumb {
  box-shadow: 1px 1px 1px #000031;
  border: 1px solid #00001E;
  height: 26px;
  width: 26px;
  border-radius: 15px;
  background: #FFFFFF;
  cursor: pointer;
}
input[type=range]::-ms-track {
  width: 100%;
  height: 11px;
  cursor: pointer;
  animate: 0.2s;
  background: transparent;
  border-color: transparent;
  color: transparent;
}
input[type=range]::-ms-fill-lower {
  background: #74A9D8;
  border: 0px solid #010101;
  border-radius: 2px;
  box-shadow: 1px 1px 1px #000000;
}
input[type=range]::-ms-fill-upper {
  background: #74A9D8;
  border: 0px solid #010101;
  border-radius: 2px;
  box-shadow: 1px 1px 1px #000000;
}
input[type=range]::-ms-thumb {
  margin-top: 1px;
  box-shadow: 1px 1px 1px #000031;
  border: 1px solid #00001E;
  height: 26px;
  width: 26px;
  border-radius: 15px;
  background: #FFFFFF;
  cursor: pointer;
}
input[type=range]:focus::-ms-fill-lower {
  background: #74A9D8;
}
input[type=range]:focus::-ms-fill-upper {
  background: #74A9D8;
}
</style>
</head>
<body>
    <div>
         <div class="gpx_label">Primary GPX file (drawn in solid colors)</div><input type="file" id="gpx1">
        <br>
        <div class="gpx_label">Secondary GPX file (drawn in dotted lines)</div> <input type="file" id="gpx2"> 
        <div class="gpx_label" id="advanced_settings_toggle">Advanced Settings [+]</div>
        <div class="advanced_settings" id="advanced_settings" style="display:none">
            <input type="number" id="bucket_size" min="1" value="3" max="6"></input> Degrees per segment (integers, 1-6)
        </div>
    </div>
    <div id="wind_angle">
        <h1>Wind Angle (in degrees, default is south)</h1>
        <span>0</span> <input id="angle" type="range" min="0" max="360" step="0.5"></input> <span>360</span>
        <div id="current_angle"></div>
    </div>
    <div id="canvas_container"><canvas id="canvas" width="1200" height="1200"></canvas></div>
</body>
</html>
